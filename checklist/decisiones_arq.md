# 4. Decisiones Iniciales de Arquitectura
En esta página se resumen las decisiones tomadas para la arquitectura del aplicativo "Singletone".

## Generalidades (completado)
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Elección entre arquitectura monolítica y de microservicios | 1. Arquitectura monolítica, 2. Arquitectura de microservicios | 2. Arquitectura de microservicios |
| Asignación de responsabilidades | Asignación de responsabilidades entre módulos frontend y backend | 1. Frontend "grueso", 2. Backend "grueso", 3. Enfoque híbrido | 3. Enfoque híbrido                   |
| Asignación de responsabilidades | Responsabilidad de la gestión de la identidad y autenticación de usuarios | 1. Integrar en Gestión de Usuarios, 2. Delegar a IdP | 2. Delegar a IdP |
| Modelo de Coordinación | Mecanismo de comunicación entre microservicios | 1. Comunicación síncrona(RESTful API), 2. Comunicación asíncrona basada en eventos (Message Broker) | 1. Comunicación síncrona (RESTful API) |
| Modelo de Datos | Estrategia general de persistencia de datos | 1. Utilizar una única base de datos relacional (SQL), 2. Utilizar múltiples bases de datos relacionales (SQL) segregadas por microservicio, 3.Utilizar una combinación de bases de datos relacionales (SQL), NoSQL orientada a documentos y clave-valor | 3. Utilizar una combinación de bases de datos relacionales (SQL), NoSQL orienda a documentos y clave-valor |
| Modelado de datos | Elección sobre la estrategia de base de datos en microservicios | 1. Instancia de BD por microservicio, 2. BD compartida entre microservicios, 3. Mixto (algunos con instancia propia y otros compartida) | 1. Instancia de BD por microservicio |
| Mapeo entre elementos de Arquitectura | Mapeo de módulos funcionales a microservicios | 1. Mapeo uno a uno, 2. Mapeo agrupado, 3. Mapeo híbrido | 1. Mapeo uno a uno |
| Elección de Tecnología | Tecnología para el desarrollo del Frontend | 1. React, 2. Angular, 3. Vue.js | 1. React |
| Elección de Tecnología | Tecnología para el desarrollo del Backend | 1. Node.js con Express.js, 2. Python con Django o Flask, 3. Java con Spring Boot | 1. Node.js con Express.js |
| Elección de Tecnología | Tecnología para la base de datos relacional | 1. PostgreSQL, 2. MySQL, 3. MariaDB | 1. PostgreSQL |
| Elección de Tecnología | Tecnología para la base de datos NoSQL documental | 1. MongoDB, 2. CouchDB, 3. Amazon DocumentDB | 1. MongoDB |
| Elección de Tecnología | Tecnología para la base de datos NoSQL clave-valor | 1. Redis, 2. Amazon DynamoDB (modo clave-valor), 3. Etcd | 1. Redis |
| Elección de Tecnología | Tecnología para la orquestación de contenedores | 1. Kubernetes, 2. Docker Swarm, 3. Amazon ECS | 1. Kubernetes |

## Módulo 01 — Gestión de Usuarios: (completado) — (5/5)
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Separación de responsabilidades de registro, autenticación y gestión de usuarios | 1. Separar los controladores en tres componentes específicos, 2. Controlador único para las tres responsabilidades | 1. Separar los controladores en tres componentes específicos | 
| Modelo de Cordinación | Estrategia de coordinación entre servicios para el flujo de registro de usuarios | 1. Coordinación basada en orquestación mediante un servicio centralizado (UserService), 2. Coordinación distribuida, con múltiples servicios colaborando entre sí | 1. Coordinación basada en orquestación mediante un servicio centralizado (UserService) |
| Modelo de Datos | Modelo de Datos para Entidad Usuario y Estructura de Plan de Suscripción | 1. Modelo relacional normalizado (SQL - PostgresSQL), 2. Modelo documental (NoSQL – MongoDB) | 1. Modelo relacional normalizado (SQL - PostgresSQL) |
| Mapeo entre elementos de arquitectura | Mapeo entre elementos del frontend, backend y capa de datos para el módulo de Gestión de Usuarios | 1. Mapeo directo entre componentes (controlador → servicio → repositorio), 2. Arquitectura basada en eventos (cola de mensajes) | 1. Mapeo directo entre componentes (controlador → servicio → repositorio) |
| Elección de Tecnología | Elección del sistema de autenticación y gestión de usuarios | 1. Firebase Authentication + Firestore, 2. Backend personalizado (Node.js + Express + JWT + PostgreSQL), 3. Auth0 (IdP) | 3. Auth0 (IdP) |

## Módulo 02 — Visualización de Perfil: (por completar) — (3/5) 
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Modelo de Coordinación | Coordinación entre secciones del perfil y otros módulos (usuarios, monetización y biblioteca) | 1. Modelo basado en servicios coordinados mediante un controlador central de perfil, 2. Modelo distribuido en el que cada componente hace sus propias llamadas a servicios externos | 1. Modelo basado en servicios coordinados mediante un controlador central de perfil |
| Modelo de Datos | Estructura de datos para representar la información del perfil del usuario | 1. Modelo separado por dominios (composición de modelos especializados), 2. Modelo monolítico de perfil unificado |  1. Modelo separado por dominios (composición de modelos especializados) |
| Mapeo entre elementos de Arquitectura | Asignación de responsabilidades entre frontend y backend para el perfil del usuario | 1. El backend construye el modelo completo del perfil y lo entrega listo al frontend, 2. El backend expone endpoints separados y el frontend ensambla el perfil | 1. El backend construye el modelo completo del perfil y lo entrega listo al frontend |

## Módulo 03 — Exploración Musical: (completo) — (5/5)
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Responsabilidad exclusiva de música y visualización de resultados musicales y de usuarios | 1. Módulo de Búsqueda Pasiva, 2. Módulo de Búsqueda con Acción Delegada | 2. Módulo de Búsqueda con Acción Delegada |
| Modelo de Coordinación | Coordinación síncrona para interacción en tiempo real con módulos de Biblioteca y Perfiles | 1. Comunicación vía REST API, 2. Comunicación asíncrona vía eventos o colas de mensajes, 3. Enfoque híbrido (REST para acciones críticas y eventos para procesos secundarios) | 1. Comunicación vía REST API |
| Modelo de Coordinación | Tipo de comunicación entre el microservicio de exploración y otros módulos de la plataforma | 1. Comunicación síncrona vía HTTP (REST), 2. Comunicación asíncrona vía eventos (mensajería) | 1. Comunicación síncrona vía HTTP (REST) |
| Modelo de Datos | Estructura óptima de los documentos musicales en MongoDB para búsquedas flexibles y rendimiento en exploración | 1. Documentos planos e independientes por entidad, 2. Documentos embebidos por jerarquía de uso, 3. Modelo mixto con desnormalización parcial | 2. Documentos embebidos por jerarquía de uso |
| Mapeo entre elementos de Arquitectura | Mapeo entre la capa de búsqueda y los datos en la base documental para optimizar la exploración musical | 1. Mapeo directo con índices espejo, 2. Mapeo parcial con índices denormalizados, 3. Mapeo mediante capa de abstracción | 2. Mapeo parcial con índices denormalizados |
| Elección de Tecnología | Mecanismo de paginación y autocompletado para búsquedas en el módulo de exploración | 1. Paginación clásica con MongoDB (skip/limit) y búsqueda por prefijo, 2. Motor de búsqueda ElasticSearch con scroll infinito y `completion suggester`, 3. Cursor-based pagination con Redis para caché de autocompletado, 4. Paginación basada en cursores con MongoDB y autocompletado por prefijo con Redis como caché | 4. Paginación basada en cursores con MongoDB y autocompletado por prefijo con Redis como caché |

## Módulo 04 – Gestión de Biblioteca: (completo) — (11/11)
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Estrategia para el almacenamiento del estado de "agregado" y "valorado" de artistas y álbumes | 1. Almacenar el estado directamente en las entidades de Artista y Álbum del usuario, 2. Calcular el estado dinámicamente en base a las valoraciones del usuario, 3. Utilizar una tabla de "relación" explícita con un campo de estado | 3. Utilizar una tabla de "relación" explícita con un campo de estado |
| Asignación de responsabilidad sobre los estados “agregado” y “valorado” | Responsabilidad de la actualización del estado "agregado" y "valorado" de artistas y álbumes | 1. Responsabilidad centralizada en el microservicio de Biblioteca, 2. Responsabilidad distribuida entre servicios | 1. Responsabilidad centralizada en el microservicio de Biblioteca |
| Modelo de Coordinación | Coordinación para la eliminación de artistas y sus álbumes asociados | 1. El microservicio de Gestión de Biblioteca maneja la eliminación en cascada directamente, 2. El microservicio de Gestión de Biblioteca utiliza llamadas síncronas REST para coordinar la eliminación de álbumes con otros componentes | 1. El microservicio de Gestión de Biblioteca maneja la eliminación en cascada directamente |
| Modelo de Coordinación | Coordinación del proceso de valoración de álbumes y la activación de la opción "guardar" | 1. El frontend consulta al backend para verificar si todas las canciones han sido valoradas antes de habilitar el botón “guardar”, 2. El backend notifica al frontend mediante un canal en tiempo real cuando todas las canciones han sido valoradas, 3. El frontend gestiona el estado de las valoraciones y decide localmente cuándo habilitar el botón “guardar” | 2. El backend notifica al frontend mediante un canal en tiempo real cuando todas las canciones han sido valoradas |
| Modelo de Datos | Estructura de datos para la biblioteca del usuario | 1. Almacenar la biblioteca como una lista de referencias en el documento del usuario (en MongoDB), 2. Crear colecciones separadas en MongoDB para las relaciones usuario-artista y usuario-álbum con información de estado, 3. Utilizar tablas relacionales (en PostgreSQL) para las relaciones usuario-artista y usuario-álbum con información de estado | 2. Crear colecciones separadas en MongoDB para las relaciones usuario-artista y usuario-álbum con información de estado |
| Modelo de Datos | Estructura de datos para las valoraciones de álbumes y canciones | 1. Incorporar las valoraciones como un subdocumento dentro del documento del álbum en la biblioteca del usuario (en MongoDB), 2. Crear una colección separada de "Valoraciones" en MongoDB, 3. Utilizar tablas relacionales (en PostgreSQL) para almacenar las valoraciones | 2. Crear una colección separada de "Valoraciones" en MongoDB |
| Modelo de Datos | Metadatos para artistas, álbumes y canciones | 1. Almacenar todos los metadatos en una única colección "Música" en MongoDB, 2. Crear colecciones separadas en MongoDB para "Artistas", "Álbumes" y "Canciones, 3. Utilizar tablas relacionales (en PostgreSQL) para almacenar los metadatos | 3. Crear colecciones separadas en MongoDB para "Artistas", "Álbumes" y "Canciones" |
| Mapeo entre elementos de Arquitectura | Mapeo del modelo de datos de la biblioteca a las colecciones de MongoDB | 1. Mapeo directo: Cada entidad principal de la biblioteca corresponde a una colección, 2. Incorporar las relaciones y valoraciones como subdocumentos dentro del documento del usuario | 1. Mapeo directo: Cada entidad Incorporar las relaciones y valoraciones como subdocumentos dentro del documento del usuario |
| Mapeo entre elementos de Arquitectura | Mapeo del concepto de "estado" de artistas y álbumes a campos en la base de datos | 1. Utilizar un campo de texto (string) para el estado, 2. Utilizar un campo booleano para indicar si está "valorado", 3. Utilizar un campo numérico (entero) para representar el estado mediante un código | Utilizar un campo de texto (string) llamado `estado` |
| Eleción de Tecnología | Tecnología para la manipulación de datos en el microservicio de Gestión de Biblioteca | PostgreSQL(pg o sequelize o typeorm) y MongoDB (mongodb, mongoose, mongoskin) | PostgreSQL (sequelize), MongoDB (mongoose) |
| Elección de Tecnología | Tecnología para la comunicación en tiempo real (notificaciones de límite de valoraciones) | 1. WebSockets, 2. Server-Sent Events (SSE), 3. Polling o Long Polling | 1. WebSockets |

## Módulo 05 — Gestión de Recomendaciones: (completo) — (10/10)
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Estrategia para el almacenamiento y cálculo de recomendaciones de artistas y álbumes | 1. Almacenar recomendaciones precalculadas, 2. Calcular recomendaciones dinámicamente en tiempo real, Uso de LLM con procesamiento directo | 3. Uso de LLM con procesamiento directo |
| Asignación de Responsabilidades | Responsabilidad del cálculo de recomendaciones de artistas y álbumes | 1. El microservicio de Gestión de Recomendaciones maneja directamente el cálculo, 2. Un servicio de Machine Learning especializado calcula las recomendaciones, 3. ntegración con API de LLM externa | 3. ntegración con API de LLM externa |
| Asignación de Responsabilidades | Responsabilidad del botón "Volver a recomendar" para recalcular recomendaciones | 1. El microservicio de Gestión de Recomendaciones maneja el botón, 2. El frontend maneja la solicitud y emite un evento al backend, 3. Nueva consulta directa al LLM | 3. Nueva consulta directa al LLM |
| Modelo de Coordinación | Coordinación de la recomendación de artistas basada en las valoraciones del usuario | 1. Consulta directa de valoraciones por el microservicio de Recomendaciones, 2. Perfil de usuario mantenido por el microservicio de Recomendaciones, 3. Recepción de eventos REST de valoraciones para actualización dinámica | 3. Recepción de eventos REST de valoraciones para actualización dinámica |
| Modelo de Coordinación | Coordinación de la generación de recomendaciones personalizadas | 1. El microservicio de Recomendaciones usa un algoritmo de filtrado colaborativo basado en las interacciones de usuarios similares, 2. El microservicio de Recomendaciones utiliza un perfil explícito del usuario basado en sus preferencias de género y artistas previos, 3. El microservicio de Recomendaciones utiliza un enfoque híbrido que combina filtrado colaborativo y perfil del usuario | 3. El microservicio de Recomendaciones utiliza un enfoque híbrido que combina filtrado colaborativo y perfil del usuario |
| Modelo de Coordinación | Actualización de recomendaciones mediante tareas en segundo plano con REST API | 1. Actualización síncrona tras cada valoración, 2. Actualización en segundo plano con REST API y polling, 3. Actualización en segundo plano con Webhooks o Websockets (no compatible con REST API puro) | 2. Actualización en segundo plano con REST API y polling |
| Modelo de Datos | Representación de las recomendaciones como entidad independiente | 1. Generación dinámica sin persistencia, 2. Entidad persistente de recomendaciones | 2. Entidad persistente de recomendaciones |
| Mapeo entre elementos de Arquitectura | Mapeo del modelo de recomendaciones personalizadas a las colecciones de MongoDB | 1. Mapeo directo con colección exclusiva para recomendaciones, 2. Incrustar recomendaciones dentro del documento del usuario | 1. Mapeo directo con colección exclusiva para recomendaciones |
| Elección de Tecnología | Elección de Tecnología para el Módulo de Recomendaciones Personalizadas en Singletone | 1. Modelo de Machine Learning Propio, 2. API basada en LLM | 2. API basada en LLM |
| Elección de Tecnología | Plataforma para consumo de modelos LLM | 1. Hugging Face Inference API, 2. OpenAI API, 3. AWS Bedrock | 1. Hugging Face Inference API |

## Módulo 06 — Gestión de Planes: (completo) — (10/10)
| Tipo de decisión         | Título                                                     | Alternativas    | Decisión         |
|--------------------------|------------------------------------------------------------|------------------------------------------|-----------------------------------|
| Asignación de Responsabilidades | Separación de responsabilidades entre gestión de planes, procesamiento de pagos y habilitación de funcionalidades premium | 1. Componente monolítico de gestión de planes, 2. Separación en componentes especializados | 2. Separación en componentes especializados |
| Asignación de Responsabilidades | Responsabilidad de la notificación de límites de valoraciones para usuarios con plan gratuito | 1. Responsabilidad del microservicio de Gestión de Biblioteca, 2. Responsabilidad del microservicio de Gestión de Planes | 2. Responsabilidad del microservicio de Gestión de Planes |
| Modelo de Coordinación | Coordinación del flujo de registro premium con procesamiento de pagos mediante Stripe | 1. Coordinación secuencial síncrona, 2. Coordinación asíncrona basada en eventos | 1. Coordinación secuencial síncrona |
| Modelo de Coordinación | Coordinación para la habilitación y deshabilitación de funcionalidades premium en tiempo real | 1. Coordinación centralizada mediante servicio orquestador, 2. Coordinación distribuida con notificaciones directas | 1. Coordinación centralizada mediante servicio orquestador |
| Modelo de Datos | Estructura de datos para planes de suscripción y información de pago de usuarios | 1. Modelo relacional en PostgreSQL, 2. Modelo híbrido PostgreSQL + Redis | 2. Modelo híbrido PostgreSQL + Redis |
| Modelo de Datos | Almacenamiento de límites y contadores de uso para planes gratuitos | 1. Almacenamiento en PostgreSQL con tabla de contadores, 2. Almacenamiento en Redis con expiración automática | 2. Almacenamiento en Redis con expiración automática |
| Mapeo entre elementos de Arquitectura | Mapeo del concepto de "plan de suscripción" a las estructuras de datos en PostgreSQL y Redis | 1. Mapeo directo con sincronización manual, 2. Mapeo optimizado por uso con sincronización automática | 2. Mapeo optimizado por uso con sincronización automática |
| Mapeo entre elementos de Arquitectura | Mapeo de funcionalidades premium a permisos verificables por otros módulos | 1. Mapeo mediante sistema de permisos granular, 2. Mapeo mediante flag binario de estado premium | 1. Mapeo mediante sistema de permisos granular |
| Elección de Tecnología | Elección de plataforma de procesamiento de pagos para suscripciones premium | 1. Stripe, 2. PayPal, 3. Mercado Pago | 1. Stripe |
| Elección de Tecnología | Tecnología para notificaciones en tiempo real de límites de valoraciones | 1. WebSockets, 2. Server-Sent Events (SSE), 3. Polling periódico | 1. WebSockets |
